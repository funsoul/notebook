
## 分类

1. 时间复杂度（最差、平均、和最好性能）: 列表（list）的大小n。一般而言，好的性能是O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))，坏的性能是O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))。对于一个排序理想的性能是O(n)，但平均而言不可能达到。基于比较的排序算法对大多数输入而言至少需要O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))。
2. 空间复杂度
3. 稳定性: 稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。

## 时间复杂度

## 空间复杂度

## 稳定性

### 稳定的

1. 冒泡排序（bubble sort）: O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))
2. 插入排序（insertion sort）: O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))
3. 鸡尾酒排序（cocktail sort）: O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))
4. 桶排序（bucket sort）: O(n)；需要O(k)额外空间
5. 计数排序（counting sort）: O(n+k)；需要O(n+k)额外空间
6. 归并排序（merge sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))；需要O(n)额外空间
7. 原地归并排序 : O(n\log^2 n)如果使用最佳的现在版本
8. 二叉排序树排序（binary tree sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))期望时间；O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))最坏时间；需要O(n)额外空间
9. 鸽巢排序（pigeonhole sort）: O(n+k)；需要O(k)额外空间
10. 基数排序（radix sort）: O(nk)；需要O(n)额外空间
11. 侏儒排序（gnome sort）: O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))
12. 图书馆排序（library sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))期望时间；O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))最坏时间；需要(![](https://microsoft.codecogs.com/svg.latex?1+\varepsilon))n额外空间
13. 块排序（block sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))

### 不稳定的

1. 选择排序（selection sort）: O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))
2. 希尔排序（shell sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log^2%20n))如果使用最佳的现在版本
3. 克洛弗排序（Clover sort）: O(n)期望时间，O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))最坏情况
4. 梳排序 : O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))
5. 堆排序（heap sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))
6. 平滑排序（smooth sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))
7. 快速排序（quick sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))期望时间，O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))最坏情况；对于大的、随机数列表一般相信是最快的已知排序
8. 内省排序（introsort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))
9. 耐心排序（patience sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n+k))最坏情况时间，需要额外的O(n+k)空间，也需要找到最长的递增子序列（longest increasing subsequence）

### 不实用的

1. Bogo排序 : O(![](https://microsoft.codecogs.com/svg.latex?n\times%20n!))，最坏的情况下期望时间为无穷。
2. Stupid排序 : O(n^{3});递归版本需要O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))额外存储器
3. 珠排序（bead sort）: O(n) 或 O(![](https://microsoft.codecogs.com/svg.latex?\sqrt%20{n})),但需要特别的硬件
4. 煎饼排序 : O(n),但需要特别的硬件
5. 臭皮匠排序（stooge sort）算法简单，但需要约![](https://microsoft.codecogs.com/svg.latex?n^{2.7})的时间

## 代码实现

todo

## 参考

1. [排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)