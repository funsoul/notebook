
## 分类

1. 时间复杂度（最差、平均、和最好性能）: 列表（list）的大小n。一般而言，好的性能是O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))，坏的性能是O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))。对于一个排序理想的性能是O(n)，但平均而言不可能达到。基于比较的排序算法对大多数输入而言至少需要O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))。
2. 空间复杂度
3. 稳定性: 稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。
4. 比较

## 时间复杂度

![图片来自Wiki](https://upload.wikimedia.org/wikipedia/commons/0/0c/SortingAlgoComp.png)

## 空间复杂度

## 稳定性

### 稳定的

1. 冒泡排序（bubble sort）: O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))
2. 插入排序（insertion sort）: O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))
3. 鸡尾酒排序（cocktail sort）: O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))
4. 桶排序（bucket sort）: O(n)；需要O(k)额外空间
5. 计数排序（counting sort）: O(n+k)；需要O(n+k)额外空间
6. 归并排序（merge sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))；需要O(n)额外空间
7. 原地归并排序 : O(n\log^2 n)如果使用最佳的现在版本
8. 二叉排序树排序（binary tree sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))期望时间；O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))最坏时间；需要O(n)额外空间
9. 鸽巢排序（pigeonhole sort）: O(n+k)；需要O(k)额外空间
10. 基数排序（radix sort）: O(nk)；需要O(n)额外空间
11. 侏儒排序（gnome sort）: O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))
12. 图书馆排序（library sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))期望时间；O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))最坏时间；需要(![](https://microsoft.codecogs.com/svg.latex?1+\varepsilon))n额外空间
13. 块排序（block sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))

### 不稳定的

1. 选择排序（selection sort）: O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))
2. 希尔排序（shell sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log^2%20n))如果使用最佳的现在版本
3. 克洛弗排序（Clover sort）: O(n)期望时间，O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))最坏情况
4. 梳排序 : O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))
5. 堆排序（heap sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))
6. 平滑排序（smooth sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))
7. 快速排序（quick sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))期望时间，O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))最坏情况；对于大的、随机数列表一般相信是最快的已知排序
8. 内省排序（introsort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n))
9. 耐心排序（patience sort）: O(![](https://microsoft.codecogs.com/svg.latex?n\log%20n+k))最坏情况时间，需要额外的O(n+k)空间，也需要找到最长的递增子序列（longest increasing subsequence）

### 不实用的

1. Bogo排序 : O(![](https://microsoft.codecogs.com/svg.latex?n\times%20n!))，最坏的情况下期望时间为无穷。
2. Stupid排序 : O(n^{3});递归版本需要O(![](https://microsoft.codecogs.com/svg.latex?n^{2}))额外存储器
3. 珠排序（bead sort）: O(n) 或 O(![](https://microsoft.codecogs.com/svg.latex?\sqrt%20{n})),但需要特别的硬件
4. 煎饼排序 : O(n),但需要特别的硬件
5. 臭皮匠排序（stooge sort）算法简单，但需要约![](https://microsoft.codecogs.com/svg.latex?n^{2.7})的时间

## 比较

### 基于比较

1. 冒泡
2. 选择
3. 插入
4. 归并（递归实现）
5. 快速（递归实现）
6. 随机快速（递归实现）

### 不基于比较

1. 计数排序
2. 基数排序
3. 桶排序

## 代码实现

全部代码都已上传到[Github](https://github.com/funsoul/sort-py)

### 冒泡排序

![BubbleSort](/images/数据结构和算法/排序/BubbleSort.gif)

```py
class BubbleSort(Base):
    def execute(self, L: List[int]) -> List[int]:
        for i in range(0, self.length):
            for j in range(i + 1, self.length):
                if L[i] > L[j]:
                    L[i], L[j] = L[j], L[i]
        return L
```

#### 分析

比较和交换需要一个以常量为界的时间，我们称之为c。
（标准）Bubble Sort中有两个嵌套循环。
外循环正好运行N次迭代。 但内部循环运行变得越来越短：

1. 当 i = 0，（N-1）次迭代（比较和可能交换）时。
2. 当 i = 1，（N-2）次迭代时，...
3. 当 i =（N-2）时，1次迭代,
4. 当 i=（N-1），0迭代.
5. 因此，总迭代次数=（N-1）+（N-2）+ ... + 1 + 0 = N *（N-1）/ 2。
6. 总时间= c * N *（N-1）/ 2 = O（N ^ 2）。

### 鸡尾酒排序

鸡尾酒排序等于是冒泡排序的轻微变形。不同的地方在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的性能，原因是冒泡排序只从一个方向进行比对（由低到高），每次循环只移动一个项目。

以序列（2,3,4,5,1）为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。

![CocktailSort](/images/数据结构和算法/排序/CocktailSort.gif)

```py
class CocktailSort(Base):
    def execute(self, L: List[int]) -> List[int]:
        flag = True
        for i in range(len(L) // 2):
            if flag:
                flag = False
                for j in range(i, len(L) - i - 1):
                    if L[j] > L[j+1]:
                        L[j], L[j+1] = L[j+1], L[j]
                        flag = True

                for j in range(len(L) - 1 - i, i, -1):
                    if L[j] < L[j-1]:
                        L[j], L[j-1] = L[j-1], L[j]
                        flag = True
            else:
                break
        return L
```

#### 分析

1. 时间复杂度：鸡尾酒排序的效率还是很低的，两层循环，时间复杂度为 O(n^2) 。
2. 空间复杂度：由于只需要几个临时变量，所以空间复杂度为 O(1) 。

### 插入排序

![InsertionSort](/images/数据结构和算法/排序/InsertionSort.gif)

```py
class InsertionSort(Base):
    def execute(self, L: List[int]) -> List[int]:
        for p in range(1, self.length):
            tmp = L[p]
            i = p
            while i > 0 and L[i-1] > tmp:
                L[i] = L[i-1]
                i = i-1
            L[i] = tmp
        return L
```

#### 分析

外循环执行N-1次
内循环执行的次数取决于输入：

1. 在最好的情况下，数组已经排序并且（L[i-1] > tmp）总是为假所以不需要移位数据，并且内部循环运行在O（1），
2. 在最坏的情况下，数组被反向排序并且（L[i-1] > tmp）始终为真插入始终发生在数组的前端，并且内部循环以O（N）运行。

因此，最佳情况时间是O(N × 1) = O(N) ，最坏情况时间是O(N × N) = O(N2).


## 参考

1. [排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)
2. [visualgo](https://visualgo.net/)