本篇为[云风](https://blog.codingnow.com/)翻译的[《程序员修炼之道——通往务实的最高境界》](https://book.douban.com/subject/35006892/)第二版的读书笔记

## 第1章，务实的哲学

### 人生是你的

1. 别等待技能过时，寻求提升和突破、不断尝试有趣的东西、扩充边界
2. 无论是职业、岗位、工作和团队，都有权选择

主动改变

### 我的源码被猫吃了

1. 赢得团队信任，小心维护，别破坏它
2. 承担责任，提供选择，别找借口

责任、坦诚

### 软件的熵

>破窗效应：一扇破损的窗户，只要一段时间不修理，建筑中的居民就会潜移默化地产生一种被遗弃的感觉——当权者不关心这幢建筑的感觉。然后其他的窗户也开始损坏，居民开始乱丢废物，墙上开始出现涂鸦，建筑开始出现严重的结构性损坏。心理学家的研究表明，绝望是会传染的，就像狭窄空间中的流感病毒。无视一个明显损坏的东西，会强化这样一种观念：看来没有什么是能修好的，也没人在乎，一切都命中决定了。所有的负面情绪会在团队成员间蔓延，变成恶性循环。

1. 不要放任破窗，遇到问题（糟糕的设计、错误的决定、低劣的代码）不要回避，及早面对。不要让熵赢得胜利。
2. 不要只是因为一些东西非常危机，就去造成附带损害。破窗一扇都嫌太多。
3. “不要打破窗户”

软件规模带来的后增的重量

### 石头做的汤和煮熟的青蛙

1. 找出合理的请求，不断完善。一旦有成果产出，展示给人们看。引导推进，让大家能窥视未来。
2. 牢记全景，审视大局，而不要只专注个人在做的事情。

展示前景，做推动变革的催化剂

### 够好即可的软件

1. 完成用户需求，达到基本的性能、隐私和安全标准。
2. 与构想中的明天那个完美的软件相比，今天就还不错的软件通常更讨人喜欢。（人们不愿意等待、用户需求也有时效问题）
3. 不要让过度的修饰和精炼侵蚀掉一个完好的程序。

知道何时止步

### 知识组合

1. 知识和经验是最重要的专业资产，但是也是一种时效资产。
2. 构建知识组合
    1. 定期投资
        1. 每年学习一门新语言
        2. 每月读一本技术书
        3. 读非技术书
        4. 上课
        5. 加入社群
        6. 尝试不同的环境（开发环境）
        7. 与时俱进
    2. 多样化：知道的越多，价值越大。熟悉的技能越多，越能适应变化。
    3. 风险管理：不要把所有的技术鸡蛋都放在一个篮子里。
    4. 低买高卖：在一项新兴技术变得流行之前就开始学习。
    5. 重新评估调整：不断尝试，温故而知新
3. 学习的机会（与人交流、碎片化阅读）
4. 批评性思维：知识的精确性容易受到商业主义的影响
    1. 多问“为什么“
    2. （世俗的怀疑）谁从中受益
    3. 有什么背景：每件事都发生在它自己的背景下
    4. 什么时候在哪里可以工作起来：当它结束后还会发生什么（二阶思考）
    5. 为什么这是个问题

知识与想法的交叉传授

### 交流！

1. 多层次交流
    1. 开会
    2. 与终端用户合作
    3. 编写代码
    4. 编写文档
    5. 写建议和备忘录
2. 英语：当成一门编程语言来使用（DRY、ETC、自动化）
3. 了解听众：收集反馈，不要只是等待问题的出现，把问题问出来。
4. 明白自己想说什么
5. 想法很重要，但还有一个好看的包装（布局、样式、一致性）
6. 让听众参与
7. 做倾听者
8. 回应别人
9. 说什么和怎么说同样重要
10. 把代码和文档绑在一起

## 第2章，务实的方法

### 优秀设计的精髓

优秀的设计比糟糕的设计更容易变更（Easy to Change）

### DRY——邪恶的重复

>作为程序员，我们做的就是收集、组织、维护以及治理知识。我们把知识文档化，写进规范；通过运行代码赋予知识以活力；在测试过程中，运用知识去知道应提供哪些检查。不幸的是，知识并不稳定。知识会改变——通常频率还很高。

**在一个系统中，每一处知识都必须单一、明确、权威地表达**

1. DRY原则——不要重复自己
    1. 不限于编码
    2. 针对知识和意图的复制（并不是所有的代码重复都是知识的重复）
    3. 文档中的重复（代码注释：代码的意图被描述两次）
    4. 统一访问：一个模块提供的所有服务都应该通过统一的约定来提供，该约定不应表露出其内部实现是基于储存还是基于运算的。（来自《面向对象软件构造》）
    5. 表征重复：指两个事物（代码和外部实体）必须拥有接口的表征知识。一端发生改变，另一端就会坏掉。下面是一些减缓的策略
        1. 内部API间的重复：通过一个工具用来将API描述成一种中立的格式。保存起来，共享给不同的团队（如前后端）
        2. 外部API间的重复：制定正式的规范，可以方便你将API规范导入到本地API工具
        3. 数据源引起的重复：
            1. 数据源支持schema内省：不必手工编写代码来将要储存的数据包含其中，可以直接从schema生成容器代码
            2. 使用键值对数据结构，同时增加一层表驱动的校验组件。
    6. 开发人员间的重复
        1. 从高的层次看：建立一个强大的、紧密联系的、沟通良好的团队
        2. 模块间的重复：鼓励开发人员积极频繁的交流
            1. 组织[Scrum晨会](http://www.woshipm.com/zhichang/153792.html)
            2. 开一个论坛（Slack频道），为每件说的事做永久记录
        3. 指派一名知识管理员，工作为促进知识的传播

### [正交性](https://baike.baidu.com/item/%E6%AD%A3%E4%BA%A4%E6%80%A7)

   1. 含义：在计算机科学中，象征着独立性和解耦性
   2. 作用：消除不相关事物之间的影响（设计的组件自成一体：内聚）
   3. 好处
     1. 提高生产力
         1. 减少开发和测试时间
         2. 系统变得松散耦合
         3. 正交组件可组合使用
     2. 减少风险
         1. 代码中病变的部分被隔离开
         2. 变更与修复产生的任何问题都仅局限在特定区域
         3. 利于测试
         4. 与外部组件结合，不会被束缚的太紧密
   4. 设计
     3. 当一个功能需求被变更后，受到影响的模块应该只有一个
     4. 不要依赖那些你无法控制的东西
   5. 工具包和程序库：引入第三方工具包和程序库时，注意保持系统的正交性。
   6. 编码
     5. 保持代码解耦
     6. 避免全局数据（创建一个包含上下文的数据结构，并将结构传递出去）
     7. 避免相似的函数（策略模式）
   7. 测试：模块（单元）测试
   8. 文档：如markdown，关注内容，把样式呈现留给其他工具去处理

### 可逆性

   1. 不设最终决定
   2. 灵活的架构（除了代码，还要考虑体系结构、部署和供应商集成方面）
   3. 放弃追逐时尚

### 曳光弹
   1. 使用曳光弹找到目标
      1. 用户能够更早的获得能工作的东西
      2. 开发者构造了一个可以在其中工作的框架
      3. 你有了一个集成平台
      4. 你有演示的东西
      5. 你对进度有更好的感觉
   2. 曳光弹并不总能击中目标

### 原型与标签

   1. 需要做原型的东西
      1. 架构
      2. 已存在的系统中的新功能
      3. 数据结构或外部数据的内容
      4. 第三方工具或组件
      5. 性能问题
      6. 用户界面设计
   2. 怎样使用原型
      1. 可忽略的细节
         1. 正确性
         2. 完整性
         3. 健壮性
         4. 格式
      2. 使用高阶语言开山辟路（粘合剂、未来会丢弃原型）
   3. 制作架构原型
      1. 不必编写代码
      2. 使用白板贴标签和索引卡
      3. 尽量推迟思考细节
   3. 不要把原型用于产品

### 领域语言

   1. 靠近问题域编程
   2. 权衡内部语言和外部语言

### 估算

   1. 通过估算来避免意外
   2. 多精确才够：挑选答案的单位来反映想要传达的精确性
   3. 估算从何而来
      1. 理解在问什么：掌握问题域的范围
      2. 对系统建模：对于一个项目，可能是开发组织在开发期间需要的每个步骤，以及关于系统可能如何实现的粗略图景
      3. 把模型分解成组件
      4. 确定每个参数的值
      5. 计算答案
      6. 记录你的估算能力
   4. 估算项目进度
      1. PERT（计划评审技术）：每个任务都有一个乐观的、一个最有可能的和一个悲观的估算
      2. 项目时间表（怎样吃掉大象？一次咬一口）
         1. 检查需求
         2. 分析风险
         3. 设计、实现、集成
         4. 和用户一起验证
         5. 记录迭代的结束点，回到最初（检查需求），不断迭代进度表
      3. 放慢节奏：被要求做一个估算时，应该说“我等一下答复你”

## 第3章，基础工具

1. 工具会放大你的才能
2. 定期给自己的工具箱添加工具
3. 让业务需求来驱动自己选择不同（新的）工具

### 纯文本的威力

1. 将知识用纯文本保存
   1. 类型: HTML/JSON/YAML/HTTP..
   2. 优势
      1. 为防备老化而加保险
      2. 利用杠杆效应让已有工具发挥最大优势：版本控制、编辑器、命令行工具都会用到
      3. 易于测试
      4. 最小公分母：纯文本可作为各方相互沟通的公共标准
   
### Shell游戏

1. GUI
   1. 优势：操作简单、**所见即所得**
   2. 缺点：无法使用工具的全部能力、自动化能力弱、**所见即全部**
2. 配置自己的专属Shell
      1. 主题
      2. 提示信息
      3. 别名和Shell函数
      4. 命令补全

### 加强编辑能力

1. 游刃有余地使用编辑器：不用鼠标、触摸板完成日常编辑工作
2. 逐步游刃有余
   1. 自省：发现自己又在重复做某件事情，要习惯性地想到，还有更好的办法，然后找到这个办法
   2. 内化：重复使用好的方法，将其内化为肌肉记忆

### 版本控制

1. 共享目录绝非版本控制
2. 从源码开始，逐步将所有的内容（文档、电话号码列表、shell脚本..）都提交到版本控制系统
3. 使用分支
   1. 隔离特性
   2. 团队工作流
4. 将版本控制视为项目中枢，需要支持以下功能
   1. 有良好的安全和访问权限控制
   2. 有符合直觉的界面
   3. 支持命令行来实现操作（自动化）
   4. 自动化构建和测试
   5. Pull Request
   6. 问题管理
   7. 漂亮的报告
   8. 团队交流（发邮件等通知方式）

### 调试

1. 调试心理学
   1. 去解决问题，而不是责备
   2. 不要恐慌bug，永远去发掘问题的根本原因，而不仅仅停留在问题的表面现象
2. 调试策略
   1. 拜访报告bug的用户
   2. 测试所有边界，复原实际的最终用户使用模式（重现bug）
   3. 输入值的敏感度（特定数据集）
   4. 二分法（分割数据集、分割调用栈、分割版本）
   5. 输出日志及跟踪信息
   6. 像他人解释问题
   7. 排除法

### 文本处理

学习一门文本处理语言

1. shell
2. python/ruby类的语言

### 工程日记

试着拥有一本工程日记

1. 比记忆更可靠
2. 提供了一个地方，保存与当前任务无关的想法
3. 当你停下来，把东西写上去的时候，大脑可能会换挡，几乎就像在和某人说话一样——这是一个反思的好机会。
4. 就是日记，以便回想起曾经的你在做些什么

## 第4章，务实的偏执

### 契约式设计（DBC）

1. 文档化及对主张进行检验是契约式设计的核心
   1. 前置条件：传递良好的数据
   2. 后置条件：不允许无限循环
   3. 类的不变式
   4. 契约：如果调用者满足了例程的所有前置条件，则例程应保证在完成时所有后置条件和不变式都为真。
   5. 与正交性相比，契约强调编写“懒惰”的代码


To be continue..